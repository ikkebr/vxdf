/**
 * API client for the VXDF validation engine.
 * Handles communication with the backend server.
 */

// Base URL for API requests - using relative path with proxy in development
const API_BASE_URL = '/api';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  category: string;
  cwe?: string;
  source: {
    file: string;
    line: number;
    snippet?: string;
  };
  sink: {
    file: string;
    line: number;
    snippet?: string;
  };
  steps?: Array<{
    file: string;
    line: number;
    snippet?: string;
    note: string;
  }>;
  exploitable?: boolean;
  validated?: boolean;
  validationDate?: string;
  validationMessage?: string;
  evidence?: Array<{
    description: string;
    method: string;
    timestamp: string;
    content?: string;
  }>;
  createdAt?: string;
}

export interface ValidationResult {
  vulnerability: Vulnerability;
  isExploitable: boolean;
  evidence: {
    description: string;
    method: string;
    timestamp: string;
    content?: string;
  }[];
}

export interface UploadResult {
  success: boolean;
  message: string;
  findings: Vulnerability[];
  outputFile: string;
}

export interface StatsResult {
  total: number;
  validated: number;
  exploitable: number;
  nonExploitable: number;
  inProgress: number;
  bySeverity: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    informational: number;
  };
  byType: Record<string, number>;
  recentFindings: Vulnerability[];
}

/**
 * Upload security scan files for validation.
 * 
 * @param files Files to upload
 * @param options Upload options
 * @returns Upload result with validated vulnerabilities
 */
export async function uploadScanFile(
  file: File, 
  options: {
    parserType?: string;
    validate?: boolean;
    targetName?: string;
    targetVersion?: string;
    vulnTypes?: string[];
    minSeverity?: string;
  } = {}
): Promise<UploadResult> {
  const formData = new FormData();
  formData.append('file', file);
  
  // Add options to form data
  if (options.parserType) {
    formData.append('parser_type', options.parserType);
  }
  
  if (options.validate !== undefined) {
    formData.append('validate', options.validate ? 'true' : 'false');
  }
  
  if (options.targetName) {
    formData.append('target_name', options.targetName);
  }
  
  if (options.targetVersion) {
    formData.append('target_version', options.targetVersion);
  }
  
  if (options.vulnTypes && options.vulnTypes.length > 0) {
    options.vulnTypes.forEach(type => {
      formData.append('vuln_types', type);
    });
  }
  
  if (options.minSeverity) {
    formData.append('min_severity', options.minSeverity);
  }
  
  const response = await fetch(`${API_BASE_URL}/upload`, {
    method: 'POST',
    body: formData,
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to upload scan file: ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Get a list of vulnerabilities.
 * 
 * @param options Filtering options
 * @returns List of vulnerabilities and pagination info
 */
export async function getVulnerabilities(
  options: {
    limit?: number;
    offset?: number;
    category?: string;
    exploitable?: boolean;
    severity?: string;
  } = {}
): Promise<{vulnerabilities: Vulnerability[], total: number, limit: number, offset: number}> {
  const params = new URLSearchParams();
  
  if (options.limit) {
    params.append('limit', options.limit.toString());
  }
  
  if (options.offset) {
    params.append('offset', options.offset.toString());
  }
  
  if (options.category) {
    params.append('category', options.category);
  }
  
  if (options.exploitable !== undefined) {
    params.append('exploitable', options.exploitable ? 'true' : 'false');
  }
  
  if (options.severity) {
    params.append('severity', options.severity);
  }
  
  const response = await fetch(`${API_BASE_URL}/vulnerabilities?${params.toString()}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch vulnerabilities');
  }
  
  return await response.json();
}

/**
 * Get detailed information about a specific vulnerability.
 * 
 * @param id Vulnerability ID
 * @returns Detailed vulnerability information
 */
export async function getVulnerability(id: string): Promise<Vulnerability> {
  const response = await fetch(`${API_BASE_URL}/vulnerabilities/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch vulnerability details');
  }
  
  return await response.json();
}

/**
 * Get dashboard statistics.
 * 
 * @returns Stats for the dashboard
 */
export async function getStats(): Promise<StatsResult> {
  const response = await fetch(`${API_BASE_URL}/stats`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch stats');
  }
  
  return await response.json();
}

/**
 * Get supported vulnerability types.
 * 
 * @returns List of supported vulnerability types
 */
export async function getSupportedTypes(): Promise<{vulnerabilityTypes: string[]}> {
  const response = await fetch(`${API_BASE_URL}/supported-types`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch supported types');
  }
  
  return await response.json();
}